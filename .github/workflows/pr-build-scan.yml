name: Pull Request - Build and Scan

on:
  pull_request:
    branches:
      - main
    paths:
      - "managed-containers/**"

permissions: read-all

jobs:
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.mk-matrix.outputs.matrix }}
      count: ${{ steps.mk-matrix.outputs.count }}
    permissions:
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Generated Changed Files JSON
        id: changed
        run: |
          set -euo pipefail
          base="${{ github.event.pull_request.base.sha }}"
          head="${{ github.sha }}"

          # Use -z for NUL-delimited robustness; also filter to managed-containers/**
          changed_files_json="$(
            git diff --name-only -z "$base" "$head" -- 'managed-containers/**' \
            | jq -Rs 'split("\u0000") | map(select(length>0))'
          )"

          echo "Changed files JSON:"
          echo "$changed_files_json" | jq '.'

          {
            echo 'changed_files<<__JSON__'
            echo "$changed_files_json"
            echo '__JSON__'
          } >> "$GITHUB_OUTPUT"

      - name: Generated associated effected Dockerfiles.
        id: mk-matrix
        run: |
          set -euo pipefail

          changed_files_json='${{ steps.changed.outputs.changed_files }}'

          # Derive unique component roots: managed-containers/<component>
          components="$(
            echo "$changed_files_json" \
            | jq -r '.[]' \
            | awk -F/ '/^managed-containers\// && NF>=2 {print $1"/"$2}' \
            | awk '!seen[$0]++'
          )"

          dockerfiles_list_raw=""

          # Include top-level Dockerfile per component if present
          while IFS= read -r comp; do
            [ -z "$comp" ] && continue
            if [ -f "$comp/Dockerfile" ]; then
              dockerfiles_list_raw+="$comp/Dockerfile"$'\n'
            fi
          done <<< "$components"

          # Also include any Dockerfiles that were themselves changed (nested images)
          direct_dockerfiles="$(
            echo "$changed_files_json" | jq -r '.[]' | grep -E '(^|/)[Dd]ockerfile$' || true
          )"
          dockerfiles_list_raw+="$direct_dockerfiles"$'\n'

          # Normalize paths, dedupe, AND CHECK EXISTENCE
          normalized_paths="$(
            printf '%s' "$dockerfiles_list_raw" \
            | sed '/^$/d; s#^\./##; s#/\+#/#g' \
            | while IFS= read -r p; do
                [ -z "$p" ] && continue
                
                # Resolve path (handle ../ and .)
                resolved_path=$(realpath -m -- "$p")
                
                # If the Dockerfile was deleted in this PR, 'realpath' resolves the string,
                # but '-f' will return false, preventing it from being added to the build matrix.
                if [ -f "$resolved_path" ]; then
                  echo "$resolved_path"
                fi
              done
          )"

          dockerfiles_all="$(printf '%s\n' "$normalized_paths" | awk '!seen[$0]++')"
          count="$(printf '%s\n' "$dockerfiles_all" | sed '/^$/d' | wc -l | tr -d ' ')"

          echo "Found $count Dockerfile(s) to build:"
          printf '%s\n' "$dockerfiles_all"

          if [ "$count" -eq 0 ]; then
            echo 'matrix={"include":[]}' >> "$GITHUB_OUTPUT"
            echo "count=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build matrix include array; sanitize image tag to be Docker-safe
          # Docker refname allowed: [a-z0-9._-] and must start with [a-z0-9]
          matrix_json=$(
            while IFS= read -r dockerfile; do
              [ -z "$dockerfile" ] && continue
              context="$(dirname -- "$dockerfile")"
              base="$(basename -- "$context")"
              safe_base="$(printf '%s' "$base" \
                | tr '[:upper:]' '[:lower:]' \
                | sed -E 's/[^a-z0-9._-]+/-/g; s/^-+//; s/-+$//; s/-{2,}/-/g')"
              [ -z "$safe_base" ] && safe_base="image"
              image_name="${safe_base}:latest"
              printf '{"dockerfile":"%s","context":"%s","image":"%s"}\n' \
                "$dockerfile" "$context" "$image_name"
            done <<< "$dockerfiles_all" | jq -s '{include: .}'
          )

          {
            echo 'matrix<<__JSON__'
            echo "$matrix_json"
            echo '__JSON__'
          } >> "$GITHUB_OUTPUT"
          echo "count=$count" >> "$GITHUB_OUTPUT"

  build-and-scan:
    permissions:
      id-token: write
    needs: [prepare-matrix]
    if: ${{ fromJson(needs.prepare-matrix.outputs.count) > 0 }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      # max-parallel: 3
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 #v6.0.1

      - name: Check for GC Secure Artifacts usage
        id: check-jfrog
        run: |
          set -euo pipefail
          dockerfile="${{ matrix.dockerfile }}"

          if grep -Eq '^[[:space:]]*FROM[[:space:]]+artifacts-artefacts\.devops\.cloud-nuage\.canada\.ca/' "$dockerfile"; then
            echo "Detected JFrog base image reference"
            echo "uses_jfrog=true" >> "$GITHUB_OUTPUT"
          else
            echo "No JFrog base image found"
            echo "uses_jfrog=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup GC Secure Artifacts and JFrog CLI
        if: ${{ steps.check-jfrog.outputs.uses_jfrog == 'true' }}
        id: setup-jfrog-cli
        uses: jfrog/setup-jfrog-cli@279b1f629f43dd5bc658d8361ac4802a7ef8d2d5 #v4.9.1
        env:
          JF_URL: https://artifacts-artefacts.devops.cloud-nuage.canada.ca
        with:
          oidc-provider-name: github-oidc

      - name: GC Secure Artifacts Docker login
        if: ${{ steps.check-jfrog.outputs.uses_jfrog == 'true' }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 #v3.7.0
        with:
          registry: https://artifacts-artefacts.devops.cloud-nuage.canada.ca
          username: ${{ steps.setup-jfrog-cli.outputs.oidc-user }}
          password: ${{ steps.setup-jfrog-cli.outputs.oidc-token }}

      - name: Validate top-level folder (no spaces under managed-containers/)
        run: |
          set -euo pipefail
          file="${{ matrix.dockerfile }}"

          # Reduce to the path segment starting at managed-containers/
          rel_path="$(printf '%s\n' "$file" | sed -E 's#^.*(managed-containers/.*)$#\1#')"
          # Extract the immediate folder name under managed-containers/
          component="$(printf '%s\n' "$rel_path" | awk -F/ '{print $2}')"

          if printf '%s' "$component" | grep -q '[[:space:]]'; then
            echo "::error title=Invalid component folder name::The top-level folder under 'managed-containers' contains whitespace: '$component'. Rename it (use '-' or '_'). Spaces are allowed in subfolders. Offending path: $rel_path"
            exit 1
          fi

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@b5ca514318bd6ebac0fb2aedd5d36ec1b5c232a2 # v3

      - name: Setup Trivy
        uses: aquasecurity/setup-trivy@ff1b8b060f23b650436d419b5e13f67f5d4c3087 # v0.2.2

      - name: Build image
        run: |
          set -euo pipefail
          echo "Building ${{ matrix.image }} from ${{ matrix.dockerfile }} (context: ${{ matrix.context }})"
          docker buildx build \
            --load \
            --no-cache \
            -t "${{ matrix.image }}" \
            -f "${{ matrix.dockerfile }}" \
            "${{ matrix.context }}"

      - name: Scan (Trivy, CRITICAL only)
        run: |
          set -euo pipefail
          img="${{ matrix.image }}"
          echo "Saving and scanning image: $img"
          docker save "$img" -o image.tar
          trivy image --quiet --format table --exit-code 1 --severity CRITICAL --input image.tar
          rm -f image.tar